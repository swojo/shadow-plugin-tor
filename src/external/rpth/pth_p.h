/* pth_p.h -- autogenerated from /home/sam/shadow2/src/external/rpth/pth_p.h.in, DO NOT EDIT! */
#line 1 "/home/sam/shadow2/src/external/rpth/pth_p.h.in"
/*
**  GNU Pth - The GNU Portable Threads
**  Copyright (c) 1999-2006 Ralf S. Engelschall <rse@engelschall.com>
**
**  This file is part of GNU Pth, a non-preemptive thread scheduling
**  library which can be found at http://www.gnu.org/software/pth/.
**
**  This library is free software; you can redistribute it and/or
**  modify it under the terms of the GNU Lesser General Public
**  License as published by the Free Software Foundation; either
**  version 2.1 of the License, or (at your option) any later version.
**
**  This library is distributed in the hope that it will be useful,
**  but WITHOUT ANY WARRANTY; without even the implied warranty of
**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
**  Lesser General Public License for more details.
**
**  You should have received a copy of the GNU Lesser General Public
**  License along with this library; if not, write to the Free Software
**  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
**  USA, or contact Ralf S. Engelschall <rse@engelschall.com>.
**
**  pth_p.h: Pth private API definitions
*/

#ifndef _PTH_P_H_
#define _PTH_P_H_

/* mandatory system headers */
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <setjmp.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <time.h>

/* library version */
#define _PTH_VERS_C_AS_HEADER_
#include "pth_vers.c"
#undef  _PTH_VERS_C_AS_HEADER_

/* public API headers */
#define _PTH_PRIVATE
#include "rpth.h"
#undef _PTH_PRIVATE

/* autoconf defines and macros */
#include "pth_acdef.h"
#include "pth_acmac.h"

/* optional system headers */
#ifdef HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#endif
#ifdef HAVE_NET_ERRNO_H
#include <net/errno.h>
#endif
#ifdef HAVE_DLFCN_H
#include <dlfcn.h>
#endif

/* dmalloc support */
#ifdef PTH_DMALLOC
#include <dmalloc.h>
#endif

/* OSSP ex support */
#ifdef PTH_EX
#define __EX_NS_USE_CUSTOM__
#include "ex.h"
#endif

/* paths */
#ifdef HAVE_PATHS_H
#include <paths.h>
#endif
#ifdef _PATH_BSHELL
#define PTH_PATH_BINSH _PATH_BSHELL
#else
#define PTH_PATH_BINSH "/bin/sh"
#endif

/* non-blocking flags */
#ifdef  O_NONBLOCK
#define O_NONBLOCKING O_NONBLOCK
#else
#ifdef  O_NDELAY
#define O_NONBLOCKING O_NDELAY
#else
#ifdef  FNDELAY
#define O_NONBLOCKING FNDELAY
#else
#error "No O_NONBLOCK, O_NDELAY or FNDELAY flag available!"
#endif
#endif
#endif

/* fallback definition for fdset_t size */
#if !defined(FD_SETSIZE)
#define FD_SETSIZE 1024
#endif

/* fallback definition for struct timespec */
#ifndef HAVE_STRUCT_TIMESPEC
struct timespec {
    time_t  tv_sec;     /* seconds */
    long    tv_nsec;    /* and nanoseconds */
};
#endif

/* compiler happyness: avoid ``empty compilation unit'' problem */
#define COMPILER_HAPPYNESS(name) \
    const int __##name##_unit = 0;

/* generated contents */
BEGIN_DECLARATION
#line 36 "/home/sam/shadow2/src/external/rpth/pth_compat.c"
#if !defined(HAVE_STRERROR)
char *_pth_compat_strerror(int);
#define strerror(errnum) _pth_compat_strerror(errnum)
#endif
#line 31 "/home/sam/shadow2/src/external/rpth/pth_debug.c"

#ifndef PTH_DEBUG

#define pth_debug1(a1)                     /* NOP */
#define pth_debug2(a1, a2)                 /* NOP */
#define pth_debug3(a1, a2, a3)             /* NOP */
#define pth_debug4(a1, a2, a3, a4)         /* NOP */
#define pth_debug5(a1, a2, a3, a4, a5)     /* NOP */
#define pth_debug6(a1, a2, a3, a4, a5, a6) /* NOP */

#else

#define pth_debug1(a1)                     pth_debug(__FILE__, __LINE__, 1, a1)
#define pth_debug2(a1, a2)                 pth_debug(__FILE__, __LINE__, 2, a1, a2)
#define pth_debug3(a1, a2, a3)             pth_debug(__FILE__, __LINE__, 3, a1, a2, a3)
#define pth_debug4(a1, a2, a3, a4)         pth_debug(__FILE__, __LINE__, 4, a1, a2, a3, a4)
#define pth_debug5(a1, a2, a3, a4, a5)     pth_debug(__FILE__, __LINE__, 5, a1, a2, a3, a4, a5)
#define pth_debug6(a1, a2, a3, a4, a5, a6) pth_debug(__FILE__, __LINE__, 6, a1, a2, a3, a4, a5, a6)

#endif /* PTH_DEBUG */

#line 68 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
#if PTH_SYSCALL_HARD
/* hard syscall mapping */
#if HAVE_SYS_SYSCALL_H
#include <sys/syscall.h>
#endif
#ifdef HAVE_SYS_SOCKETCALL_H
#include <sys/socketcall.h>
#endif
#define pth_sc(func) pth_sc_##func
#else /* !PTH_SYSCALL_HARD */
/* no hard syscall mapping */
#define pth_sc(func) func
#endif /* PTH_SYSCALL_HARD */
#line 113 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
typedef int (*pth_syscall_fct_t)();
typedef struct {
    char             *name;    /* name of system/function call */
    pth_syscall_fct_t addr;    /* address of wrapped system/function call */
} pth_syscall_fct_tab_t;
typedef struct {
    char             *path;    /* path to dynamic library */
    void             *handle;  /* handle of dynamic library */
} pth_syscall_lib_tab_t;
#line 30 "/home/sam/shadow2/src/external/rpth/pth_errno.c"

/* enclose errno in a block */
#define pth_shield \
        for ( pth_gctx_get()->pth_errno_storage = errno, \
              pth_gctx_get()->pth_errno_flag = TRUE; \
              pth_gctx_get()->pth_errno_flag; \
              errno = pth_gctx_get()->pth_errno_storage, \
              pth_gctx_get()->pth_errno_flag = FALSE )

/* return plus setting an errno value */
#if defined(PTH_DEBUG)
#define pth_error(return_val,errno_val) \
        (errno = (errno_val), \
        pth_debug4("return 0x%lx with errno %d(\"%s\")", \
                   (unsigned long)(return_val), (errno), strerror((errno))), \
        (return_val))
#else
#define pth_error(return_val,errno_val) \
        (errno = (errno_val), (return_val))
#endif

#line 55 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
#define pth_ring_elements(r) \
    ((r) == NULL ? (-1) : (r)->r_nodes)
#line 61 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
#define pth_ring_first(r) \
    ((r) == NULL ? NULL : (r)->r_hook)
#line 67 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
#define pth_ring_last(r) \
    ((r) == NULL ? NULL : ((r)->r_hook == NULL ? NULL : (r)->r_hook->rn_prev))
#line 73 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
#define pth_ring_next(r, rn) \
    (((r) == NULL || (rn) == NULL) ? NULL : ((rn)->rn_next == (r)->r_hook ? NULL : (rn)->rn_next))
#line 79 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
#define pth_ring_prev(r, rn) \
    (((r) == NULL || (rn) == NULL) ? NULL : ((rn)->rn_prev == (r)->r_hook->rn_prev ? NULL : (rn)->rn_prev))
#line 85 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
#define pth_ring_insert(r, rn) \
    pth_ring_append((r), (rn))
#line 175 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
#define pth_ring_push(r, rn) \
    pth_ring_prepend((r), (rn))
#line 208 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
#define pth_ring_enqueue(r, rn) \
    pth_ring_prepend((r), (rn))
#line 30 "/home/sam/shadow2/src/external/rpth/pth_mctx.c"

/*
 * machine context state structure
 *
 * In `jb' the CPU registers, the program counter, the stack
 * pointer and (usually) the signals mask is stored. When the
 * signal mask cannot be implicitly stored in `jb', it's
 * alternatively stored explicitly in `sigs'. The `error' stores
 * the value of `errno'.
 */

#if PTH_MCTX_MTH(mcsc)
#include <ucontext.h>
#endif

typedef struct pth_mctx_st pth_mctx_t;
struct pth_mctx_st {
#if PTH_MCTX_MTH(mcsc)
    ucontext_t uc;
    int restored;
#elif PTH_MCTX_MTH(sjlj)
    pth_sigjmpbuf jb;
#else
#error "unknown mctx method"
#endif
    sigset_t sigs;
#if PTH_MCTX_DSP(sjlje)
    sigset_t block;
#endif
    int error;
};

/*
** ____ MACHINE STATE SWITCHING ______________________________________
*/

/*
 * save the current machine context
 */
#if PTH_MCTX_MTH(mcsc)
#define pth_mctx_save(mctx) \
        ( (mctx)->error = errno, \
          (mctx)->restored = 0, \
          getcontext(&(mctx)->uc), \
          (mctx)->restored )
#elif PTH_MCTX_MTH(sjlj) && PTH_MCTX_DSP(sjlje)
#define pth_mctx_save(mctx) \
        ( (mctx)->error = errno, \
          pth_sc(sigprocmask)(SIG_SETMASK, &((mctx)->block), NULL), \
          pth_sigsetjmp((mctx)->jb) )
#elif PTH_MCTX_MTH(sjlj)
#define pth_mctx_save(mctx) \
        ( (mctx)->error = errno, \
          pth_sigsetjmp((mctx)->jb) )
#else
#error "unknown mctx method"
#endif

/*
 * restore the current machine context
 * (at the location of the old context)
 */
#if PTH_MCTX_MTH(mcsc)
#define pth_mctx_restore(mctx) \
        ( errno = (mctx)->error, \
          (mctx)->restored = 1, \
          (void)setcontext(&(mctx)->uc) )
#elif PTH_MCTX_MTH(sjlj)
#define pth_mctx_restore(mctx) \
        ( errno = (mctx)->error, \
          (void)pth_siglongjmp((mctx)->jb, 1) )
#else
#error "unknown mctx method"
#endif

/*
 * restore the current machine context
 * (at the location of the new context)
 */
#if PTH_MCTX_MTH(sjlj) && PTH_MCTX_DSP(sjlje)
#define pth_mctx_restored(mctx) \
        pth_sc(sigprocmask)(SIG_SETMASK, &((mctx)->sigs), NULL)
#else
#define pth_mctx_restored(mctx) \
        /*nop*/
#endif

/*
 * switch from one machine context to another
 */
#define SWITCH_DEBUG_LINE \
        "==== THREAD CONTEXT SWITCH ==========================================="
#ifdef PTH_DEBUG
#define  _pth_mctx_switch_debug pth_debug(NULL, 0, 1, SWITCH_DEBUG_LINE);
#else
#define  _pth_mctx_switch_debug /*NOP*/
#endif
#if PTH_MCTX_MTH(mcsc)
#define pth_mctx_switch(old,new) \
    _pth_mctx_switch_debug \
    swapcontext(&((old)->uc), &((new)->uc));
#elif PTH_MCTX_MTH(sjlj)
#define pth_mctx_switch(old,new) \
    _pth_mctx_switch_debug \
    if (pth_mctx_save(old) == 0) \
        pth_mctx_restore(new); \
    pth_mctx_restored(old);
#else
#error "unknown mctx method"
#endif

#line 33 "/home/sam/shadow2/src/external/rpth/pth_uctx.c"

/* user-space context structure */
struct pth_uctx_st {
    int         uc_stack_own; /* whether stack were allocated by us */
    char       *uc_stack_ptr; /* pointer to start address of stack area */
    size_t      uc_stack_len; /* size of stack area */
    int         uc_mctx_set;  /* whether uc_mctx is set */
    pth_mctx_t  uc_mctx;      /* saved underlying machine context */
};

/* trampoline context */
typedef struct {
    pth_mctx_t *mctx_parent;
    pth_uctx_t  uctx_this;
    pth_uctx_t  uctx_after;
    void      (*start_func)(void *);
    void       *start_arg;
} pth_uctx_trampoline_t;

#line 31 "/home/sam/shadow2/src/external/rpth/pth_clean.c"

typedef struct pth_cleanup_st pth_cleanup_t;
struct pth_cleanup_st {
    pth_cleanup_t *next;
    void (*func)(void *);
    void *arg;
};

#line 31 "/home/sam/shadow2/src/external/rpth/pth_time.c"
#define PTH_TIME_NOW  (pth_time_t *)(0)
#define PTH_TIME_ZERO &pth_time_zero
#define PTH_TIME(sec,usec) { sec, usec }
#define pth_time_equal(t1,t2) \
        (((t1).tv_sec == (t2).tv_sec) && ((t1).tv_usec == (t2).tv_usec))
#line 57 "/home/sam/shadow2/src/external/rpth/pth_time.c"
#if defined(HAVE_GETTIMEOFDAY_ARGS1)
#define __gettimeofday(t) gettimeofday(t)
#else
#define __gettimeofday(t) gettimeofday(t, NULL)
#endif
#define pth_time_set(t1,t2) \
    do { \
        if ((t2) == PTH_TIME_NOW) \
            __gettimeofday((t1)); \
        else { \
            (t1)->tv_sec  = (t2)->tv_sec; \
            (t1)->tv_usec = (t2)->tv_usec; \
        } \
    } while (0)
#line 109 "/home/sam/shadow2/src/external/rpth/pth_time.c"
#define pth_time_add(t1,t2) \
    (t1)->tv_sec  += (t2)->tv_sec; \
    (t1)->tv_usec += (t2)->tv_usec; \
    if ((t1)->tv_usec >= 1000000) { \
        (t1)->tv_sec  += 1; \
        (t1)->tv_usec -= 1000000; \
    }
#line 120 "/home/sam/shadow2/src/external/rpth/pth_time.c"
#define pth_time_sub(t1,t2) \
    (t1)->tv_sec  -= (t2)->tv_sec; \
    (t1)->tv_usec -= (t2)->tv_usec; \
    if ((t1)->tv_usec < 0) { \
        (t1)->tv_sec  -= 1; \
        (t1)->tv_usec += 1000000; \
    }
#line 29 "/home/sam/shadow2/src/external/rpth/pth_tcb.c"

#define PTH_TCB_NAMELEN 40

    /* thread control block */
struct pth_st {
    /* priority queue handling */
    pth_t          q_next;               /* next thread in pool                         */
    pth_t          q_prev;               /* previous thread in pool                     */
    int            q_prio;               /* (relative) priority of thread when queued   */

    /* standard thread control block ingredients */
    int            prio;                 /* base priority of thread                     */
    char           name[PTH_TCB_NAMELEN];/* name of thread (mainly for debugging)       */
    int            dispatches;           /* total number of thread dispatches           */
    pth_state_t    state;                /* current state indicator for thread          */

    /* timing */
    pth_time_t     spawned;              /* time point at which thread was spawned      */
    pth_time_t     lastran;              /* time point at which thread was last running */
    pth_time_t     running;              /* time range the thread was already running   */

    /* event handling */
    pth_event_t    events;               /* events the thread is waiting for            */

    /* per-thread signal handling */
    sigset_t       sigpending;           /* set    of pending signals                   */
    int            sigpendcnt;           /* number of pending signals                   */

    /* machine context */
    pth_mctx_t     mctx;                 /* last saved machine state of thread          */
    char          *stack;                /* pointer to thread stack                     */
    unsigned int   stacksize;            /* size of thread stack                        */
    long          *stackguard;           /* stack overflow guard                        */
    int            stackloan;            /* stack type                                  */
    void        *(*start_func)(void *);  /* start routine                               */
    void          *start_arg;            /* start argument                              */
    int            valgrind_id;

    /* thread joining */
    int            joinable;             /* whether thread is joinable                  */
    void          *join_arg;             /* joining argument                            */

    /* per-thread specific storage */
    const void   **data_value;           /* thread specific  values                     */
    int            data_count;           /* number of stored values                     */

    /* cancellation support */
    int            cancelreq;            /* cancellation request is pending             */
    unsigned int   cancelstate;          /* cancellation state of thread                */
    pth_cleanup_t *cleanups;             /* stack of thread cleanup handlers            */

    /* mutex ring */
    pth_ring_t     mutexring;            /* ring of aquired mutex structures            */

#ifdef PTH_EX
    /* per-thread exception handling */
    ex_ctx_t       ex_ctx;               /* exception handling context                  */
#endif
};

#line 31 "/home/sam/shadow2/src/external/rpth/pth_util.c"
#define pth_util_min(a,b) \
        ((a) > (b) ? (b) : (a))
#line 30 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"

/* thread priority queue */
struct pth_pqueue_st {
    pth_t q_head;
    int   q_num;
};
typedef struct pth_pqueue_st pth_pqueue_t;

#line 165 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"
#define pth_pqueue_favorite_prio(q) \
    ((q)->q_head != NULL ? (q)->q_head->q_prio + 1 : PTH_PRIO_MAX)
#line 199 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"
#define pth_pqueue_elements(q) \
    ((q) == NULL ? (-1) : (q)->q_num)
#line 205 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"
#define pth_pqueue_head(q) \
    ((q) == NULL ? NULL : (q)->q_head)
#line 31 "/home/sam/shadow2/src/external/rpth/pth_event.c"

/* pre-declare type of function event callback
   (mainly to workaround va_arg(3) problems below) */
typedef int (*pth_event_func_t)(void *);

/* event structure */
struct pth_event_st {
    struct pth_event_st *ev_next;
    struct pth_event_st *ev_prev;
    pth_status_t ev_status;
    int ev_type;
    int ev_goal;
    union {
        struct { int fd; }                                          FD;
        struct { sigset_t *sigs; int *sig; }                        SIGS;
        struct { pth_time_t tv; int fd; }                           TIME;
        struct { pth_msgport_t mp; }                                MSG;
        struct { pth_mutex_t *mutex; }                              MUTEX;
        struct { pth_cond_t *cond; }                                COND;
        struct { pth_t tid; }                                       TID;
        struct { pth_event_func_t func; void *arg; pth_time_t tv; int fd;} FUNC;
    } ev_args;
};

#line 30 "/home/sam/shadow2/src/external/rpth/pth_data.c"

struct pth_keytab_st {
    int used;
    void (*destructor)(void *);
};

#line 30 "/home/sam/shadow2/src/external/rpth/pth_msg.c"

/* message port structure */
struct pth_msgport_st {
    pth_ringnode_t mp_node;  /* maintainance node handle */
    const char    *mp_name;  /* optional name of message port */
    pth_t          mp_tid;   /* corresponding thread */
    pth_ring_t     mp_queue; /* queue of messages pending on port */
};

#line 30 "/home/sam/shadow2/src/external/rpth/pth_attr.c"

enum {
    PTH_ATTR_GET,
    PTH_ATTR_SET
};

struct pth_attr_st {
    pth_t        a_tid;
    int          a_prio;
    int          a_dispatches;
    char         a_name[PTH_TCB_NAMELEN];
    int          a_joinable;
    unsigned int a_cancelstate;
    unsigned int a_stacksize;
    char        *a_stackaddr;
};

#line 32 "/home/sam/shadow2/src/external/rpth/pth_fork.c"

struct pth_atfork_st {
    void (*prepare)(void *);
    void (*parent)(void *);
    void (*child)(void *);
    void *arg;
};

#line 32 "/home/sam/shadow2/src/external/rpth/pth_lib.c"

struct pth_gctx_st {
	int pth_is_async;
    int pth_initialized;
    int pthread_initialized;
    int pth_errno_storage;
    int pth_errno_flag;

    pth_uctx_trampoline_t pth_uctx_trampoline_ctx;

    pth_t        pth_main;       /* the main thread                       */
    pth_t        pth_sched;      /* the permanent scheduler thread        */
    pth_t        pth_current;    /* the currently running thread          */
    pth_pqueue_t pth_NQ;         /* queue of new threads                  */
    pth_pqueue_t pth_RQ;         /* queue of threads ready to run         */
    pth_pqueue_t pth_WQ;         /* queue of threads waiting for an event */
    pth_pqueue_t pth_SQ;         /* queue of suspended threads            */
    pth_pqueue_t pth_DQ;         /* queue of terminated threads           */
    int          pth_favournew;  /* favour new threads on startup         */
    float        pth_loadval;    /* average scheduler load value          */

    int          pth_sigpipe[2]; /* internal signal occurrence pipe       */
    sigset_t     pth_sigpending; /* mask of pending signals               */
    sigset_t     pth_sigblock;   /* mask of signals we block in scheduler */
    sigset_t     pth_sigcatch;   /* mask of signals we have to catch      */
    sigset_t     pth_sigraised;  /* mask of raised signals                */

    pth_time_t   pth_loadticknext;
    pth_time_t   pth_loadtickgap;

    int main_efd; // epoll fd

    struct pth_keytab_st pth_keytab[PTH_KEY_MAX];
    pth_key_t ev_key_join;
    pth_key_t ev_key_nap;
    pth_key_t ev_key_mutex;
    pth_key_t ev_key_cond;
    pth_key_t ev_key_sigwait_ev;
    pth_key_t ev_key_waitpid;

    pth_ring_t pth_msgport;

    pth_mutex_t mutex_pread;
    pth_mutex_t mutex_pwrite;

    struct pth_atfork_st pth_atfork_list[PTH_ATFORK_MAX];
    int pth_atfork_idx;
};

#line 114 "/home/sam/shadow2/src/external/rpth/pth_lib.c"

#define pth_implicit_init() \
    if (!pth_gctx_get()) \
        pth_init();

#line 1 "_ON_THE_FLY_"

/* make sure the scpp source extensions are skipped */
#define cpp 0
#define intern /**/

/* move intern variables to hidden namespace */
#define pth_syscall_fct_tab __pth_syscall_fct_tab
#define pth_time_zero __pth_time_zero
#define pth_state_names __pth_state_names
#define __pth_current_gctx ____pth_current_gctx

/* move intern functions to hidden namespace */
#define pth_debug __pth_debug
#define pth_dumpstate __pth_dumpstate
#define pth_dumpqueue __pth_dumpqueue
#define pth_syscall_init __pth_syscall_init
#define pth_syscall_kill __pth_syscall_kill
#define pth_sc_fork __pth_sc_fork
#define pth_sc_sigprocmask __pth_sc_sigprocmask
#define pth_sc_waitpid __pth_sc_waitpid
#define pth_sc_connect __pth_sc_connect
#define pth_sc_accept __pth_sc_accept
#define pth_sc_select __pth_sc_select
#define pth_sc_read __pth_sc_read
#define pth_sc_write __pth_sc_write
#define pth_sc_readv __pth_sc_readv
#define pth_sc_writev __pth_sc_writev
#define pth_sc_recv __pth_sc_recv
#define pth_sc_send __pth_sc_send
#define pth_sc_recvfrom __pth_sc_recvfrom
#define pth_sc_sendto __pth_sc_sendto
#define pth_ring_init __pth_ring_init
#define pth_ring_insert_after __pth_ring_insert_after
#define pth_ring_insert_before __pth_ring_insert_before
#define pth_ring_delete __pth_ring_delete
#define pth_ring_prepend __pth_ring_prepend
#define pth_ring_append __pth_ring_append
#define pth_ring_pop __pth_ring_pop
#define pth_ring_favorite __pth_ring_favorite
#define pth_ring_dequeue __pth_ring_dequeue
#define pth_ring_contains __pth_ring_contains
#define pth_mctx_set __pth_mctx_set
#define pth_mctx_set __pth_mctx_set
#define pth_mctx_set __pth_mctx_set
#define pth_mctx_set __pth_mctx_set
#define pth_mctx_set __pth_mctx_set
#define pth_mctx_set __pth_mctx_set
#define pth_cleanup_popall __pth_cleanup_popall
#define pth_time_cmp __pth_time_cmp
#define pth_time_div __pth_time_div
#define pth_time_mul __pth_time_mul
#define pth_time_t2d __pth_time_t2d
#define pth_time_t2i __pth_time_t2i
#define pth_time_pos __pth_time_pos
#define pth_tcb_alloc __pth_tcb_alloc
#define pth_tcb_free __pth_tcb_free
#define pth_util_sigdelete __pth_util_sigdelete
#define pth_util_cpystrn __pth_util_cpystrn
#define pth_util_fd_valid __pth_util_fd_valid
#define pth_pqueue_init __pth_pqueue_init
#define pth_pqueue_insert __pth_pqueue_insert
#define pth_pqueue_delmax __pth_pqueue_delmax
#define pth_pqueue_delete __pth_pqueue_delete
#define pth_pqueue_favorite __pth_pqueue_favorite
#define pth_pqueue_increase __pth_pqueue_increase
#define pth_pqueue_tail __pth_pqueue_tail
#define pth_pqueue_walk __pth_pqueue_walk
#define pth_pqueue_contains __pth_pqueue_contains
#define pth_scheduler_init __pth_scheduler_init
#define pth_scheduler_drop __pth_scheduler_drop
#define pth_scheduler_kill __pth_scheduler_kill
#define pth_scheduler __pth_scheduler
#define pth_sched_eventmanager __pth_sched_eventmanager
#define pth_sched_eventmanager_sighandler __pth_sched_eventmanager_sighandler
#define pth_key_destroydata __pth_key_destroydata
#define pth_mutex_releaseall __pth_mutex_releaseall
#define pth_attr_ctrl __pth_attr_ctrl
#define pth_thread_exists __pth_thread_exists
#define pth_thread_cleanup __pth_thread_cleanup
#define pth_readv_faked __pth_readv_faked
#define pth_writev_iov_bytes __pth_writev_iov_bytes
#define pth_writev_iov_advance __pth_writev_iov_advance
#define pth_writev_faked __pth_writev_faked
#define pth_vsnprintf __pth_vsnprintf
#define pth_snprintf __pth_snprintf
#define pth_vasprintf __pth_vasprintf
#define pth_asprintf __pth_asprintf

/* prototypes for intern variables */
#line 136 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern pth_syscall_fct_tab_t pth_syscall_fct_tab[];
#line 40 "/home/sam/shadow2/src/external/rpth/pth_time.c"
extern const pth_time_t pth_time_zero;
#line 92 "/home/sam/shadow2/src/external/rpth/pth_tcb.c"
extern const char *pth_state_names[];
#line 98 "/home/sam/shadow2/src/external/rpth/pth_lib.c"
extern __thread pth_gctx_t __pth_current_gctx;

/* prototypes for intern functions */
#line 55 "/home/sam/shadow2/src/external/rpth/pth_debug.c"
extern void pth_debug(const char *, int, int, const char *, ...);
#line 81 "/home/sam/shadow2/src/external/rpth/pth_debug.c"
extern void pth_dumpstate(FILE *);
#line 98 "/home/sam/shadow2/src/external/rpth/pth_debug.c"
extern void pth_dumpqueue(FILE *, const char *, pth_pqueue_t *);
#line 187 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern void pth_syscall_init(void);
#line 258 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern void pth_syscall_kill(void);
#line 298 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern pid_t pth_sc_fork(void);
#line 364 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern int pth_sc_sigprocmask(int, const sigset_t *, sigset_t *);
#line 399 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern pid_t pth_sc_waitpid(pid_t, int *, int);
#line 421 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern int pth_sc_connect(int, const struct sockaddr *, socklen_t);
#line 451 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern int pth_sc_accept(int, struct sockaddr *, socklen_t *);
#line 482 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern int pth_sc_select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
#line 530 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern ssize_t pth_sc_read(int, void *, size_t);
#line 552 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern ssize_t pth_sc_write(int, const void *, size_t);
#line 574 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern ssize_t pth_sc_readv(int, const struct iovec *, int);
#line 596 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern ssize_t pth_sc_writev(int, const struct iovec *, int);
#line 640 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern ssize_t pth_sc_recv(int, void *, size_t, int);
#line 664 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern ssize_t pth_sc_send(int, void *, size_t, int);
#line 688 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern ssize_t pth_sc_recvfrom(int, void *, size_t, int, struct sockaddr *, socklen_t *);
#line 710 "/home/sam/shadow2/src/external/rpth/pth_syscall.c"
extern ssize_t pth_sc_sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t);
#line 45 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
extern void pth_ring_init(pth_ring_t *);
#line 91 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
extern void pth_ring_insert_after(pth_ring_t *, pth_ringnode_t *, pth_ringnode_t *);
#line 104 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
extern void pth_ring_insert_before(pth_ring_t *, pth_ringnode_t *, pth_ringnode_t *);
#line 117 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
extern void pth_ring_delete(pth_ring_t *, pth_ringnode_t *);
#line 134 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
extern void pth_ring_prepend(pth_ring_t *, pth_ringnode_t *);
#line 155 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
extern void pth_ring_append(pth_ring_t *, pth_ringnode_t *);
#line 181 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
extern pth_ringnode_t *pth_ring_pop(pth_ring_t *);
#line 192 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
extern int pth_ring_favorite(pth_ring_t *, pth_ringnode_t *);
#line 214 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
extern pth_ringnode_t *pth_ring_dequeue(pth_ring_t *);
#line 225 "/home/sam/shadow2/src/external/rpth/pth_ring.c"
extern int pth_ring_contains(pth_ring_t *, pth_ringnode_t *);
#line 159 "/home/sam/shadow2/src/external/rpth/pth_mctx.c"
extern int pth_mctx_set(pth_mctx_t *, void (*)(void), char *, char *);
#line 234 "/home/sam/shadow2/src/external/rpth/pth_mctx.c"
extern int pth_mctx_set(pth_mctx_t *, void (*)(void), char *, char *);
#line 467 "/home/sam/shadow2/src/external/rpth/pth_mctx.c"
extern int pth_mctx_set(pth_mctx_t *, void (*)(void), char *, char *);
#line 501 "/home/sam/shadow2/src/external/rpth/pth_mctx.c"
extern int pth_mctx_set(pth_mctx_t *, void (*)(void), char *, char *);
#line 525 "/home/sam/shadow2/src/external/rpth/pth_mctx.c"
extern int pth_mctx_set(pth_mctx_t *, void (*)(void), char *, char *);
#line 546 "/home/sam/shadow2/src/external/rpth/pth_mctx.c"
extern int pth_mctx_set(pth_mctx_t *, void (*)(void), char *, char *);
#line 73 "/home/sam/shadow2/src/external/rpth/pth_clean.c"
extern void pth_cleanup_popall(pth_t, int);
#line 98 "/home/sam/shadow2/src/external/rpth/pth_time.c"
extern int pth_time_cmp(const pth_time_t *, const pth_time_t *);
#line 131 "/home/sam/shadow2/src/external/rpth/pth_time.c"
extern void pth_time_div(pth_time_t *, int);
#line 147 "/home/sam/shadow2/src/external/rpth/pth_time.c"
extern void pth_time_mul(pth_time_t *, int);
#line 157 "/home/sam/shadow2/src/external/rpth/pth_time.c"
extern double pth_time_t2d(pth_time_t *);
#line 166 "/home/sam/shadow2/src/external/rpth/pth_time.c"
extern int pth_time_t2i(pth_time_t *);
#line 175 "/home/sam/shadow2/src/external/rpth/pth_time.c"
extern int pth_time_pos(pth_time_t *);
#line 110 "/home/sam/shadow2/src/external/rpth/pth_tcb.c"
extern pth_t pth_tcb_alloc(unsigned int, void *);
#line 155 "/home/sam/shadow2/src/external/rpth/pth_tcb.c"
extern void pth_tcb_free(pth_t);
#line 42 "/home/sam/shadow2/src/external/rpth/pth_util.c"
extern int pth_util_sigdelete(int);
#line 78 "/home/sam/shadow2/src/external/rpth/pth_util.c"
extern char *pth_util_cpystrn(char *, const char *, size_t);
#line 95 "/home/sam/shadow2/src/external/rpth/pth_util.c"
extern int pth_util_fd_valid(int);
#line 42 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"
extern void pth_pqueue_init(pth_pqueue_t *);
#line 52 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"
extern void pth_pqueue_insert(pth_pqueue_t *, int, pth_t);
#line 97 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"
extern pth_t pth_pqueue_delmax(pth_pqueue_t *);
#line 128 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"
extern void pth_pqueue_delete(pth_pqueue_t *, pth_t);
#line 171 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"
extern int pth_pqueue_favorite(pth_pqueue_t *, pth_t);
#line 187 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"
extern void pth_pqueue_increase(pth_pqueue_t *);
#line 211 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"
extern pth_t pth_pqueue_tail(pth_pqueue_t *);
#line 221 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"
extern pth_t pth_pqueue_walk(pth_pqueue_t *, pth_t, int);
#line 241 "/home/sam/shadow2/src/external/rpth/pth_pqueue.c"
extern int pth_pqueue_contains(pth_pqueue_t *, pth_t);
#line 31 "/home/sam/shadow2/src/external/rpth/pth_sched.c"
extern int pth_scheduler_init(void);
#line 63 "/home/sam/shadow2/src/external/rpth/pth_sched.c"
extern void pth_scheduler_drop(void);
#line 95 "/home/sam/shadow2/src/external/rpth/pth_sched.c"
extern void pth_scheduler_kill(void);
#line 334 "/home/sam/shadow2/src/external/rpth/pth_sched.c"
extern void *pth_scheduler(void *);
#line 593 "/home/sam/shadow2/src/external/rpth/pth_sched.c"
extern void pth_sched_eventmanager(pth_time_t *, int);
#line 983 "/home/sam/shadow2/src/external/rpth/pth_sched.c"
extern void pth_sched_eventmanager_sighandler(int);
#line 97 "/home/sam/shadow2/src/external/rpth/pth_data.c"
extern void pth_key_destroydata(pth_t);
#line 127 "/home/sam/shadow2/src/external/rpth/pth_sync.c"
extern void pth_mutex_releaseall(pth_t);
#line 119 "/home/sam/shadow2/src/external/rpth/pth_attr.c"
extern int pth_attr_ctrl(int, pth_attr_t, int, va_list);
#line 508 "/home/sam/shadow2/src/external/rpth/pth_lib.c"
extern int pth_thread_exists(pth_t);
#line 520 "/home/sam/shadow2/src/external/rpth/pth_lib.c"
extern void pth_thread_cleanup(pth_t);
#line 1097 "/home/sam/shadow2/src/external/rpth/pth_high.c"
extern ssize_t pth_readv_faked(int, const struct iovec *, int);
#line 1271 "/home/sam/shadow2/src/external/rpth/pth_high.c"
extern ssize_t pth_writev_iov_bytes(const struct iovec *, int);
#line 1286 "/home/sam/shadow2/src/external/rpth/pth_high.c"
extern void pth_writev_iov_advance(const struct iovec *, int, size_t, struct iovec **, int *, struct iovec *, int);
#line 1324 "/home/sam/shadow2/src/external/rpth/pth_high.c"
extern ssize_t pth_writev_faked(int, const struct iovec *, int);
#line 647 "/home/sam/shadow2/src/external/rpth/pth_string.c"
extern int pth_vsnprintf(char *, size_t, const char *, va_list);
#line 662 "/home/sam/shadow2/src/external/rpth/pth_string.c"
extern int pth_snprintf(char *, size_t, const char *, ...);
#line 678 "/home/sam/shadow2/src/external/rpth/pth_string.c"
extern char * pth_vasprintf(const char *, va_list);
#line 693 "/home/sam/shadow2/src/external/rpth/pth_string.c"
extern char * pth_asprintf(const char *, ...);
#line 128 "/home/sam/shadow2/src/external/rpth/pth_p.h.in"
END_DECLARATION

#endif /* _PTH_P_H_ */

